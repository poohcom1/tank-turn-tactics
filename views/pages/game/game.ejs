<%- include('../../partials/head.html') %>

<style>
    body {
        background: none
    }
</style>

<body>

<div id="gameContainer"></div>

<div id="winScreen" class="panel">
    <h1>Mission Complete</h1>
    <p></p>
    <a href="/">Return to menu</a>
</div>

<div id="infoPanel" class="panel">
    <h3 id="name"></h3>
    <p id="id"></p>

    <p id="actions"></p>
    <div class="upgrade" data-upgrade="health" data-cost=2>
        <span id="health"></span>
        <span class="actionsToAdd"></span>
        <span><a class="minus">-</a><a class="plus">+</a></span>
    </div>
    <div class="upgrade" data-upgrade="range" data-cost=1>
        <span id="range"></span>
        <span class="actionsToAdd"></span>
        <span><a class="minus">-</a><a class="plus">+</a></span>
    </div>

    <span class="confirm"><a class="cancel">✘</a><a class="confirm">✓</a></span>

</div>

<div id="hintPanel" class="panel">
    <h3></h3>
    <p></p>
</div>

<script type="text/javascript" src="js/game-engine/Game.js"></script>

<script>
    let game = JSON.parse('<%- JSON.stringify(game) %>')
    let userPlayer = game.players.find(player => player.user_id === game.user_id)

    game.players = game.players.filter(p => p.health > 0)

    let gameOver = false;
    const isDead = userPlayer.health <= 0;

    if (game.players.filter(player => player.health > 0).length <= 1) {
        gameOver = true;

        document.querySelector("#winScreen").style.display = 'block'
        document.querySelector("#winScreen p").innerHTML = game.players.find(player => player.health > 0).name + " has emerged victorious"
    }

    const size = game.size
    const GRID_SIZE = 50;

    const giveRangeIncrease = 2;

    // Scores
    let actions = userPlayer.actions

    const upgradeButtons = []

    // Colors
    const c_gridLabel = 'rgba(255,255,255,0.46)';
    const c_gridLabelSelected = 'rgb(117,255,234)';

    const c_playerRange = 'rgb(117,255,234)'
    const c_enemyRange = '#ff0000'

    const c_moveBlock = 'rgba(101,249,255,0.21)'
    const c_moveCancel = 'rgba(255,242,101,0.2)'
    const c_moveOutOfRange = 'rgba(255,0,0,0.29)'
    const c_moveLine = '#60d5ff'
    const c_atkRange = 'rgba(255,0,0,0.88)'
    const c_giveRange = 'rgba(121,255,113,0.84)'

    const c_atkTarget = '#ffd271'
    const c_atkMarkedTarget = '#ff0000'

    const c_giveLine = '#73f56b'

    // Set up
    const parentDiv = document.querySelector('#gameContainer')
    const gridPadding = GRID_SIZE * 2;
    const footerPadding = 100;
    const rightPadding = 300;
    const gameDim = {
        width: size.width * GRID_SIZE + gridPadding + rightPadding,
        height: size.height * GRID_SIZE + gridPadding + footerPadding
    }

    // Fetching
    function refetch() {
        return fetch(`/game/${ game._id }`, { method: "GET" })
            .then(res => res.json())
            .then(newGame => {
                game = newGame;
                game.players = game.players.filter(p => p.health > 0)
                userPlayer = game.players.find(player => player.user_id === game.user_id)
                actions = userPlayer.actions
                updateTanks()
                updateStats()
                actionGuis.forEach(gui => gui.init())

                if (game.players.filter(player => player.health > 0).length <= 1) {
                    gameOver = true;

                    document.querySelector("#winScreen").style.display = 'block'
                    document.querySelector("#winScreen p").innerHTML = game.players.find(player => player.health > 0).name + " has emerged victorious"
                }
            })
    }

    const backgroundDriver = initDriver(parentDiv, Driver.MODE_PASSIVE, gameDim)
    backgroundDriver.canvas_ctx.save()
    backgroundDriver.canvas_ctx.font = '12px Arial'

    let focused = false;
    let showPlayerOption = !gameOver && userPlayer.actions > 0;
    let hoveredBox = { x: GRID_SIZE, y: GRID_SIZE, coords: { x: 0, y: 0 } }

    if (gameOver) {
        hoveredBox = { x: -100, y: -100, coords: { x: -1, y: -1 } }
    }

    class GridBox extends Driver.PassiveComponent {
        constructor(coords, x, y, width, height, color) {
            super();
            this.borderColor = color;

            this.coords = coords;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }

        onMouseEvent = (driver, e) => {
            if (gameOver) {
                hoveredBox = { x: -100, y: -100, coords: { x: -1, y: -1 } }
            }

            if (inBounds({ x: e.offsetX, y: e.offsetY }, this)) {
                hoveredBox = this;
            }
        }

        redraw = driver => {
            const ctx = driver.canvas_ctx;
            ctx.lineWidth = 1;
            ctx.strokeStyle = this.borderColor
            ctx.strokeRect(this.x, this.y, this.width, this.height)
        }
    }

    const grid = [];
    for (let i = 0; i < size.width; i++) {
        grid.push([])
        for (let j = 0; j < size.height; j++) {
            const gridBox = new GridBox({
                x: i,
                y: j
            }, gridPadding + i * GRID_SIZE, gridPadding + j * GRID_SIZE, GRID_SIZE, GRID_SIZE, (i + j) % 2 === 0 ? 'rgba(7,129,0,0.4)' : 'rgba(52,52,52,0.11)');

            grid[i].push(gridBox)
            backgroundDriver.components.push(gridBox)
        }
    }

    // Grid labels
    backgroundDriver.components.push(new class extends Driver.PassiveComponent {
        redraw = driver => {
            driver.canvas_ctx.textAlign = 'center'

            // Selected position
            const pos = selectedTank.player.position;

            for (let i = 0; i < game.size.height; i++) {
                driver.canvas_ctx.fillStyle = pos.y === i ? c_gridLabelSelected : c_gridLabel
                driver.canvas_ctx.fillText(`${ i + 1 }`,
                    gridPadding - GRID_SIZE + GRID_SIZE / 2,
                    i * GRID_SIZE + GRID_SIZE / 2 + gridPadding)
            }
            for (let i = 0; i < game.size.width; i++) {
                driver.canvas_ctx.fillStyle = pos.x === i ? c_gridLabelSelected : c_gridLabel
                driver.canvas_ctx.fillText(getChar(i),
                    i * GRID_SIZE + GRID_SIZE / 2 + gridPadding,
                    gridPadding - GRID_SIZE + GRID_SIZE / 2)
            }
        }
    })

    const objectDriver = initDriver(parentDiv, Driver.MODE_ACTIVE, gameDim)
    objectDriver.canvas_ctx.save();
    objectDriver.canvas_ctx.font = 'bold 15px Uni-Sans'

    let selectedTank = null;
    const ACTION_STATES = {
        SELECT: "select",
        ATK: "attack",
        MV: "move",
        GV: "give"
    }
    let actionState = ACTION_STATES.SELECT;

    class Tank extends Driver.ActiveComponent {
        constructor(player) {
            super();
            this.player = player
            this.box = this.player.box

            this.move(player.position)
        }

        refetch(player) {
            this.player = player
            this.box = this.player.box
            this.move(this.player.position)
        }

        move(pos) {
            this.box = grid[pos.x][pos.y];

            this.x = this.box.x;
            this.y = this.box.y;
            this.width = this.box.width;
            this.height = this.box.height;
        }

        update(driver) {
            // Player selection
            if (driver.mouse_events.pressed) {
                if (inBounds(driver.mouse_events, this) && actionState === ACTION_STATES.SELECT && !gameOver) {
                    showPlayerOption = !showPlayerOption

                    if (selectedTank !== userTank) {
                        showPlayerOption = true;
                    }

                    selectedTank = this;

                    if (selectedTank === userTank) {
                        enableUpgrades()
                    } else {
                        disableUpgrades()
                    }

                    if (userPlayer.actions <= 0) showPlayerOption = false;
                    updateStats()
                }
            }

            const extents = 2;
            const range = this.player.range + extents;
            const x = this.player.position.x;
            const y = this.player.position.y;
            for (let i = Math.max(x - range, 0); i <= Math.min(x + range, size.width - 1); i++) {
                for (let j = Math.max(y - range, 0); j <= Math.min(y + range, size.width - 1); j++) {

                }
            }
        }

        /**
         * @param {CanvasRenderingContext2D} ctx
         * @param {string} color
         */
        drawTriangle(ctx, color) {
            const padding = this.width / 6;
            const center = { x: this.x + this.width / 2, y: this.y + padding };
            const left = { x: this.x + padding, y: this.y + this.height - padding }
            const right = { x: this.x + this.width - padding, y: this.y + this.height - padding }

            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(right.x, right.y)
            ctx.lineTo(left.x, left.y)
            ctx.lineTo(center.x, center.y)
            ctx.closePath();
            ctx.strokeStyle = color
            ctx.lineWidth = 2
            ctx.setLineDash([])
            ctx.stroke();
            ctx.lineWidth = 1
        }

        redraw(driver) {
            const ctx = driver.canvas_ctx;
            const color = this.player.user_id === game.user_id ? 'rgb(0,255,195)' : 'rgb(255,65,65)'
            ctx.shadowColor = 'transparent'

            // Name
            if (!(actionState !== ACTION_STATES.SELECT && this === userTank)) {
                ctx.fillStyle = selectedTank === this ? 'white' : 'rgba(255,255,255,0.45)'
                ctx.textAlign = 'center'
                ctx.fillText(this.player.name, this.x + this.width / 2, this.y + this.height + 12)
                ctx.fillText(this.player.health, this.x + this.width / 2, this.y - 10)
            }


            if (selectedTank === this && actionState === ACTION_STATES.SELECT) {
                ctx.shadowColor = 'white'
                ctx.shadowBlur = 10;

                // Selection lines
                ctx.beginPath();
                ctx.moveTo(gridPadding, this.y + this.height / 2)
                ctx.lineTo(this.x, this.y + this.height / 2)
                ctx.moveTo(this.x + this.width, this.y + this.height / 2)
                ctx.lineTo(gameDim.width - rightPadding, this.y + this.height / 2)

                ctx.moveTo(this.x + this.width / 2, gridPadding)
                ctx.lineTo(this.x + this.width / 2, this.y)
                ctx.moveTo(this.x + this.width / 2, this.y + this.height)
                ctx.lineTo(this.x + this.width / 2, gameDim.height - footerPadding)
                ctx.setLineDash([])
                ctx.strokeStyle = 'rgba(14,255,229,0.55)'
                ctx.stroke()
            }

            if ((selectedTank === this || actionState === ACTION_STATES.MV)) {
                let center = this

                if (actionState === ACTION_STATES.MV && this === userTank) {
                    center = hoveredBox
                }


                if (actionState === ACTION_STATES.SELECT || actionState === ACTION_STATES.MV || actionState === ACTION_STATES.ATK) {
                    // Range
                    ctx.beginPath()
                    ctx.arc(center.x + this.width / 2, center.y + this.height / 2, this.player.range * this.width + this.width / 2, 0, 2 * Math.PI)
                    if (this.player === userPlayer) {
                        if (actionState === ACTION_STATES.ATK) {
                            if (attackGui.selectedTarget) {
                                ctx.strokeStyle = c_atkMarkedTarget
                            } else {
                                ctx.strokeStyle = c_atkTarget
                            }
                        } else {
                            ctx.strokeStyle = c_playerRange
                        }
                    } else {
                        ctx.strokeStyle = c_enemyRange
                    }

                    if (actionState === ACTION_STATES.MV) {
                        ctx.strokeStyle = "rgba(255,255,255,0.19)"
                    }

                    ctx.setLineDash([ 15, 10 ])
                    ctx.stroke()
                }

                if (actionState === ACTION_STATES.SELECT || actionState === ACTION_STATES.GV) {
                    // Give range
                    ctx.beginPath()
                    ctx.arc(center.x + this.width / 2, center.y + this.height / 2, (this.player.range + giveRangeIncrease) * this.width + this.width / 2, 0, 2 * Math.PI)
                    ctx.strokeStyle = "rgba(88,255,81,0.16)"
                    ctx.setLineDash([ 5, 2 ])
                    ctx.stroke()
                }
            }
            this.drawTriangle(ctx, color)
        }
    }

    const tanks = game.players.map(player => new Tank(player))
    tanks.forEach(t => objectDriver.components.push(t))

    function updateTanks() {
        tanks.map(tank => {
            const player = game.players.find(player => player._id === tank.player._id);
            if (player) {
                tank.refetch(player)
            } else {
                objectDriver.components.splice(objectDriver.components.indexOf(tank), 1)
                tanks.splice(objectDriver.components.indexOf(tank), 1)
            }
        })
    }

    let userTank = objectDriver.components.find(tank => tank.player.user_id === game.user_id) // Init selected tank

    if (!isDead) {
        selectedTank = userTank
    } else {
        selectedTank = tanks[0]
    }

    const guiDriver = initDriver(parentDiv, Driver.MODE_ACTIVE, gameDim)

    let moveGui, attackGui, giveGui, actionGuis;

    if (userTank) {
        class ActionPopup extends Driver.ActiveComponent {
            constructor(text, xOffset, textAlign, state, color = '#fcda6d') {
                super();

                this.userTank = userTank
                this.show = false;
                this.hover = false;
                this.selected = false;

                this.yLevel = 75;
                this.yOffset = 10;
                this.xOffset = xOffset;
                this.height = 20;
                this.color = color

                this.text = text;
                this.textAlign = textAlign;
                this.state = state;

                this.font = `${ this.height }px Uni-Sans`;

                this.bounds = null;
            }

            update(driver) {
                this.show = selectedTank.player.user_id === userPlayer.user_id && showPlayerOption && actionState === ACTION_STATES.SELECT;

                if (!this.show) return;

                const ctx = driver.canvas_ctx;

                ctx.textAlign = this.textAlign
                ctx.font = this.font

                this.bounds = {
                    x: userTank.x + this.xOffset + userTank.width / 2 - ctx.measureText(this.text).actualBoundingBoxLeft - 10,
                    y: userTank.y + this.yLevel - this.yOffset,
                    width: ctx.measureText(this.text).width + 18,
                    height: this.height + this.yOffset * 2
                }

                this.hover = inBounds(driver.mouse_events, this.bounds)
                focused = this.hover || focused

                if (this.hover && driver.mouse_events.pressed) {
                    actionState = this.state;
                    driver.mouse_events.pressed = false;
                    attackGui.init()
                }
            }

            redraw(driver) {
                if (!this.show) return;
                const ctx = driver.canvas_ctx;

                const x = userTank.x + this.xOffset + userTank.width / 2;
                const y = userTank.y + this.yLevel;

                ctx.textAlign = this.textAlign
                ctx.textBaseline = 'hanging'
                ctx.font = this.font

                ctx.fillStyle = 'rgba(0,0,0,0.47)'
                ctx.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height)

                if (this.hover) {
                    ctx.strokeStyle = this.color
                    ctx.strokeText(this.text, x, y)
                }

                ctx.fillStyle = 'white'
                ctx.fillText(this.text, x, y)
            }
        }

        const xOffset = 50;

        const moveButton = new ActionPopup("Move", -xOffset - 1, "right", ACTION_STATES.MV, c_moveLine)
        const attackButton = new ActionPopup("Attack", 0, "center", ACTION_STATES.ATK, c_atkTarget)
        const giveButton = new ActionPopup("Support", xOffset, "left", ACTION_STATES.GV, c_giveLine)

        guiDriver.components.push(moveButton)
        guiDriver.components.push(attackButton)
        guiDriver.components.push(giveButton)

        // Action guis

        // Move gui
        moveGui = new class extends Driver.ActiveComponent {
            constructor() {
                super();

                this.confirming = false;
                this.init()
            }

            init() {
                this.boxes = [ userTank.box ]; // Path from selected grid
                this.hintBoxes = [ userTank.box ]; // Show path on hover

                this.destinations = [] // Stop points of selected grid
            }

            confirmMove() {
                if (this.confirming) return;
                actionState = ACTION_STATES.SELECT

                // Remove first position (which is the player's current position)
                const positions = this.boxes.slice(1, this.boxes.length).map(box => box.coords)

                userPlayer.position = positions[positions.length - 1]
                userTank.move(positions[positions.length - 1])

                this.init()
                this.confirming = true;


                fetch(`/action/${ game._id }/move`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ positions: positions })
                })
                    .then(() => {
                        console.log("Success!")
                        refetch()
                        this.init()
                        this.confirming = false;
                    })
            }

            cancel() {
                actionState = ACTION_STATES.SELECT
                this.init()
                actions = userPlayer.actions
                updateStats()
            }

            getCurrentBox = () => this.boxes[this.boxes.length - 1]

            update(driver) {
                if (actionState !== ACTION_STATES.MV) return;

                if (this.confirming) return;

                if (driver.key_events["Escape"]) {
                    this.cancel()
                }

                const MOVE = {
                    CONFIRM: 0,
                    REMOVE: 1,
                    ADD: 2,
                    RESET: 3,
                    CANCEL: 4,
                    COLLIDE: 5
                }

                let moveType;

                // Existing spot
                if (this.destinations.includes(hoveredBox)) {
                    // Final spot
                    if (this.destinations.indexOf(hoveredBox) === this.destinations.length - 1) {
                        updateHint("Move", `[${ getChar(hoveredBox.coords.x) }${ hoveredBox.coords.y + 1 }] ` + "Press 'Enter' or click again to commit movement", c_moveLine)
                        moveType = MOVE.CONFIRM
                    } else {
                        updateHint("Move", "Click to remove succeeding waypoints")
                        moveType = MOVE.REMOVE
                    }

                    // Reset
                } else if (hoveredBox === userTank.box) {
                    if (this.boxes.length === 1) {
                        updateHint("Move", "Press 'Escape' or click to cancel movement")
                        moveType = MOVE.CANCEL
                    } else {
                        updateHint("Move", "Click to remove succeeding waypoints")
                        moveType = MOVE.RESET
                    }
                    // New spot
                } else {
                    if (!game.players.find(player => coordsEquals(player.position, hoveredBox.coords))) {
                        updateHint("Move", `[${ getChar(hoveredBox.coords.x) }${ hoveredBox.coords.y + 1 }] ` + "Click to add waypoint")
                        moveType = MOVE.ADD;
                    } else {
                        updateHint("Move", "Can't move there!")
                        moveType = MOVE.COLLIDE;
                    }
                }


                if (driver.mouse_events.pressed || driver.key_pressed["Enter"]) {
                    switch (moveType) {
                        case MOVE.ADD:
                            // Parallel position
                            if (parallelCoords(this.getCurrentBox().coords, hoveredBox.coords)) {
                                getPath(this.getCurrentBox().coords, hoveredBox.coords).forEach(c => this.boxes.push(grid[c.x][c.y]))
                            } else {
                                // Elbow position
                                const elbowCoords = connectCoords(this.getCurrentBox().coords, hoveredBox.coords);

                                getPath(this.getCurrentBox().coords, elbowCoords).forEach(c => this.boxes.push(grid[c.x][c.y]))
                                getPath(elbowCoords, hoveredBox.coords).forEach(c => this.boxes.push(grid[c.x][c.y]))
                            }

                            // Overflow
                            if (this.boxes.length > userPlayer.actions + 1) {
                                this.boxes = this.boxes.slice(0, userPlayer.actions + 1)
                                if (this.boxes.length > 1)
                                    this.destinations.push(this.getCurrentBox())
                            } else {
                                this.destinations.push(hoveredBox)
                            }
                            break;
                        case MOVE.RESET:
                            this.init()
                            break;
                        case MOVE.CANCEL:
                            this.cancel()
                            break;
                        case MOVE.CONFIRM:
                            this.confirmMove();
                            break;
                        case MOVE.REMOVE:
                            this.destinations = this.destinations.slice(0, this.destinations.indexOf(hoveredBox) + 1)
                            this.boxes = this.boxes.slice(0, this.boxes.indexOf(this.destinations[this.destinations.length - 1]) + 1)
                            if (this.destinations.length === 0) {
                                this.boxes = [ userTank.box ];
                            }
                            break;
                    }

                }

                this.hintBoxes = [];

                const elbowCoords = connectCoords(this.getCurrentBox().coords, hoveredBox.coords);

                getPath(this.getCurrentBox().coords, elbowCoords).forEach(c => this.hintBoxes.push(grid[c.x][c.y]))
                getPath(elbowCoords, hoveredBox.coords).forEach(c => this.hintBoxes.push(grid[c.x][c.y]))
            }

            drawDest(ctx, box) {
                ctx.strokeStyle = 'white'
                ctx.strokeRect(box.x + GRID_SIZE / 4, box.y + GRID_SIZE / 4, box.width - GRID_SIZE / 2, box.height - GRID_SIZE / 2)
            }

            drawCancel(ctx, box) {
                ctx.strokeStyle = 'white'
                ctx.beginPath()
                ctx.moveTo(box.x + GRID_SIZE / 4, box.y + GRID_SIZE / 4)
                ctx.lineTo(box.x + GRID_SIZE / 4 + box.width - GRID_SIZE / 2, box.y + GRID_SIZE / 4 + box.height - GRID_SIZE / 2)
                ctx.moveTo(box.x + GRID_SIZE / 4, box.y + GRID_SIZE / 4 + box.height - GRID_SIZE / 2)
                ctx.lineTo(box.x + GRID_SIZE / 4 + box.width - GRID_SIZE / 2, box.y + GRID_SIZE / 4)

                ctx.stroke()
            }

            drawConfirm(ctx, box) {
                ctx.strokeStyle = c_moveLine
                ctx.beginPath()
                ctx.arc(center(box).x, center(box).y, GRID_SIZE / 4, 0, 2 * Math.PI)
                ctx.closePath()
                ctx.stroke()
            }

            redraw(driver) {
                if (actionState !== ACTION_STATES.MV) return;

                const ctx = driver.canvas_ctx;

                ctx.strokeStyle = '#ffffff'

                const path = [ ...this.boxes, ...this.hintBoxes ]

                let onDest = false;

                for (let i = 0; i < path.length; i++) {
                    // Fill path boxes' color
                    if (onDest || hoveredBox === userTank.box) {
                        ctx.fillStyle = c_moveCancel
                    } else if (game.players.find(player => coordsEquals(player.position, hoveredBox.coords))) {
                        ctx.fillStyle = c_moveOutOfRange
                    } else {
                        ctx.fillStyle = i < userPlayer.actions + 1 ? c_moveBlock : c_moveOutOfRange
                    }

                    ctx.fillRect(path[i].x, path[i].y, path[i].width, path[i].height)

                    if (this.destinations.includes(path[i])) {
                        // Draw marks for destinations
                        if (onDest || hoveredBox === userTank.box) {
                            this.drawCancel(ctx, path[i])
                        } else if (i === this.boxes.length - 1 && hoveredBox === this.destinations[this.destinations.length - 1]) {
                            this.drawConfirm(ctx, path[i]);
                        } else {
                            this.drawDest(ctx, path[i]);
                        }

                        // If current box is the hovered box and it's not the final destination (in which we confirm instead of cancel)
                        //  or its the first box
                        if ((hoveredBox === path[i] && this.destinations.indexOf(path[i]) !== this.destinations.length - 1)
                            || hoveredBox === userTank.box) {
                            onDest = true;
                        }
                    }

                    // Skip hover if cancelling
                    if (onDest && i === this.boxes.length - 1) break;
                }

                const arrowHeadLength = 10

                // Mark targets
                game.players
                    .filter(player => inRange(hoveredBox.coords, player.position, userPlayer.range + giveRangeIncrease) && player !== userPlayer)
                    .map(player => tanks.find(t => coordsEquals(t.box.coords, player.position)))
                    .forEach(tank => {
                        if (tank.box === hoveredBox) return

                        if (inRange(hoveredBox.coords, tank.box.coords, userPlayer.range)) {
                            ctx.strokeStyle = c_atkRange
                        } else {
                            ctx.strokeStyle = c_giveRange
                        }

                        const angle = angleTo(hoveredBox, tank.box)
                        const origin = vecToPoint(5, angle - Math.PI / 2)
                        const arrowHead = vecToPoint(arrowHeadLength, angle - Math.PI / 2 - Math.PI / 4)

                        ctx.beginPath()
                        ctx.moveTo(center(hoveredBox).x + origin.x, center(hoveredBox).y + origin.y)
                        ctx.lineTo(center(tank.box).x + origin.x, center(tank.box).y + origin.y)
                        ctx.lineTo(center(tank.box).x + origin.x + arrowHead.x, center(tank.box).y + origin.y + arrowHead.y)
                        ctx.stroke();
                    })

                // Enemy range warning
                game.players
                    .forEach(p => {
                        if (p._id === userPlayer._id) return;
                        const tank = tanks.find(t => coordsEquals(t.box.coords, p.position));
                        if (tank.box === hoveredBox) return

                        if (inRange(tank.box.coords, hoveredBox.coords, p.range)) {
                            ctx.strokeStyle = c_atkRange
                        } else if (inRange(tank.box.coords, hoveredBox.coords, p.range + giveRangeIncrease)) {
                            ctx.strokeStyle = c_giveRange
                        } else {
                            return
                        }

                        const angle = angleTo(hoveredBox, tank.box)
                        const origin = vecToPoint(2, angle + Math.PI / 2)
                        const arrowHead = vecToPoint(arrowHeadLength, angle + Math.PI / 4)

                        ctx.beginPath()
                        ctx.moveTo(center(tank.box).x + origin.x, center(tank.box).y + origin.y)
                        ctx.lineTo(center(hoveredBox).x + origin.x, center(hoveredBox).y + origin.y)
                        ctx.lineTo(center(hoveredBox).x + origin.x + arrowHead.x, center(hoveredBox).y + origin.y + arrowHead.y)
                        ctx.stroke();
                    })

                actions = userPlayer.actions - path.length + 1
                updateStats()
            }
        }

        // Attack gui
        attackGui = new class extends Driver.ActiveComponent {
            constructor(props) {
                super(props);
                /**
                 * @type {Tank[]}
                 */
                this.targets = [];
                this.hoverOnSelectedTarget = false;
                this.init();
                this.confirming = false;
            }

            init() {
                this.targets = game.players
                    .filter(player => inRange(userTank.box.coords, player.position, userPlayer.range) && player !== userPlayer)
                    .map(player => tanks.find(t => coordsEquals(t.box.coords, player.position)))

                /**
                 * @type {Tank}
                 */
                this.selectedTarget = null;
            }

            confirm() {
                console.log("Attacking...")
                fetch(`/action/${ game._id }/attack/${ this.selectedTarget.player._id }`, { method: 'POST' })
                    .then(() => {
                        console.log("Attack success")
                        refetch()
                        this.cancel()
                        this.confirming = false;
                    })
            }

            cancel() {
                this.init();
                actionState = ACTION_STATES.SELECT
                updateStats()

            }

            update(driver) {
                if (actionState !== ACTION_STATES.ATK || this.confirming) return;

                updateStats()

                actions = userPlayer.actions

                if (driver.key_pressed["Escape"]) this.cancel()

                const ATTACK = {
                    NONE: -1,
                    HOVER: 0,
                    ATTACK: 1
                }

                let attackState = ATTACK.NONE

                const hoverTarget = this.targets.find(t => hoveredBox === t.box)

                this.hoverOnSelectedTarget = false;
                if (!this.selectedTarget) {
                    if (hoverTarget) {
                        updateHint("Attack", "Click to mark target")
                        attackState = ATTACK.HOVER
                    } else {
                        updateHint("Attack", "Click on a tank to mark as target")
                    }
                } else {
                    if (this.selectedTarget === hoverTarget) {
                        updateHint("Attack", "Click to commence attack on target", c_atkMarkedTarget)
                        this.hoverOnSelectedTarget = true;
                        actions = userPlayer.actions - 1
                        updateStats()
                        attackState = ATTACK.ATTACK
                    } else {
                        updateHint("Attack", "Click to remove mark")
                        attackState = ATTACK.NONE
                    }
                }


                if (driver.mouse_events.pressed) {
                    switch (attackState) {
                        case ATTACK.NONE:
                            this.selectedTarget = null
                            break;
                        case ATTACK.HOVER:
                            this.selectedTarget = hoverTarget;
                            break;
                        case ATTACK.ATTACK:
                            this.confirm();
                            this.confirming = true;
                            break;
                        default:
                    }
                }
            }

            markTargets(ctx, box, color = c_atkTarget) {
                ctx.strokeStyle = color;
                ctx.shadowColor = 'white'
                ctx.shadowBlur = 3

                const innerRadius = 5;
                const outerRadius = 17;
                const lineLength = 5;

                ctx.beginPath()
                ctx.arc(center(box).x, center(box).y, innerRadius, 0, 2 * Math.PI)
                ctx.closePath();
                ctx.stroke()

                ctx.beginPath()
                ctx.arc(center(box).x, center(box).y, outerRadius, -Math.PI / 4, Math.PI / 4)
                ctx.stroke()

                ctx.beginPath()
                ctx.arc(center(box).x, center(box).y, outerRadius, Math.PI * 3 / 4, -Math.PI * 3 / 4)
                ctx.stroke()

                ctx.moveTo(center(box).x, center(box).y + outerRadius)
                ctx.lineTo(center(box).x, center(box).y + outerRadius + lineLength)
                ctx.moveTo(center(box).x, center(box).y - outerRadius)
                ctx.lineTo(center(box).x, center(box).y - outerRadius - lineLength)

                ctx.moveTo(center(box).x + outerRadius, center(box).y)
                ctx.lineTo(center(box).x + outerRadius + lineLength, center(box).y)
                ctx.moveTo(center(box).x - outerRadius, center(box).y)
                ctx.lineTo(center(box).x - outerRadius - lineLength, center(box).y)
                ctx.stroke()

                ctx.shadowBlur = 0
            }

            redraw(driver) {
                if (actionState !== ACTION_STATES.ATK) return;
                const ctx = driver.canvas_ctx;

                this.targets.forEach(t => {
                    if (this.selectedTarget && t === this.selectedTarget) {
                        this.markTargets(ctx, t.box, c_atkMarkedTarget)
                    } else {
                        this.markTargets(ctx, t.box)
                    }

                })


            }
        }

        // Give gui
        giveGui = new class extends Driver.ActiveComponent {
            constructor(props) {
                super(props);
                /**
                 * @type {Tank[]}
                 */
                this.targets = [];
                this.hoverOnSelectedTarget = false;
                this.init();
                this.confirming = false;
            }

            init() {
                this.targets = game.players
                    .filter(player => inRange(userTank.box.coords, player.position, userPlayer.range) && player !== userPlayer)
                    .map(player => tanks.find(t => coordsEquals(t.box.coords, player.position)))

                /**
                 * @type {Tank}
                 */
                this.selectedTarget = null;
            }

            confirm() {
                console.log("Attacking...")
                fetch(`/action/${ game._id }/give/${ this.selectedTarget.player._id }/actions/1`, { method: 'POST' })
                    .then(() => {
                        console.log("Attack success")
                        refetch()
                        this.cancel()
                        this.confirming = false;
                    })
            }

            cancel() {
                this.init();
                actionState = ACTION_STATES.SELECT
                updateStats()
            }

            update(driver) {
                if (actionState !== ACTION_STATES.GV || this.confirming) return;

                updateStats()

                actions = userPlayer.actions

                if (driver.key_pressed["Escape"]) this.cancel()

                const SUPPORT = {
                    NONE: -1,
                    HOVER: 0,
                    ATTACK: 1
                }

                let supportState = SUPPORT.NONE

                const hoverTarget = this.targets.find(t => hoveredBox === t.box)

                this.hoverOnSelectedTarget = false;
                if (!this.selectedTarget) {
                    if (hoverTarget) {
                        updateHint("Support", "Click to select recipient")
                        supportState = SUPPORT.HOVER
                    } else {
                        updateHint("Support", "Click on a tank to set as recipient")
                    }
                } else {
                    if (this.selectedTarget === hoverTarget) {
                        updateHint("Support", "Click to send energy points", c_giveLine)
                        this.hoverOnSelectedTarget = true;
                        actions = userPlayer.actions - 1
                        updateStats()
                        supportState = SUPPORT.ATTACK
                    } else {
                        updateHint("Support", "Click to deselect recipient")
                        supportState = SUPPORT.NONE
                    }
                }


                if (driver.mouse_events.pressed) {
                    switch (supportState) {
                        case SUPPORT.NONE:
                            this.selectedTarget = null
                            break;
                        case SUPPORT.HOVER:
                            this.selectedTarget = hoverTarget;
                            break;
                        case SUPPORT.ATTACK:
                            this.confirm();
                            this.confirming = true;
                            break;
                        default:
                    }
                }
            }

            markTargets(ctx, box, color = 'white') {
                ctx.strokeStyle = color;
                ctx.shadowColor = 'white'
                ctx.shadowBlur = 3

                const innerRadius = 5;
                const outerRadius = 17;

                ctx.beginPath()
                ctx.arc(center(box).x, center(box).y, innerRadius, 0, 2 * Math.PI)
                ctx.closePath();
                ctx.stroke()

                ctx.beginPath()
                ctx.arc(center(box).x, center(box).y, outerRadius, 0, 2 * Math.PI)
                ctx.stroke()


                ctx.shadowBlur = 0
            }

            redraw(driver) {
                if (actionState !== ACTION_STATES.GV) return;
                const ctx = driver.canvas_ctx;

                this.targets.forEach(t => {
                    if (this.selectedTarget && t === this.selectedTarget) {
                        this.markTargets(ctx, t.box, c_giveLine)
                    } else {
                        this.markTargets(ctx, t.box)
                    }

                })


            }
        }

        actionGuis = [ moveGui, attackGui, giveGui ]

       guiDriver.components.push(...actionGuis)
    }

    // Selection
    guiDriver.components.push(new class extends Driver.ActiveComponent {
        constructor() {
            super();
            this.animationIndex = 0;
        }

        update = () => {
            this.x = hoveredBox.x;
            this.y = hoveredBox.y;
            this.width = GRID_SIZE;
            this.height = GRID_SIZE;

            this.animationIndex += 0.25;
            if (this.animationIndex >= 20) this.animationIndex = 0

            if (actionState === ACTION_STATES.SELECT) updateHint("Coordinate:", `${ getChar(hoveredBox.coords.x) }${ hoveredBox.coords.y + 1 }`)

        }

        redraw = driver => {
            if (focused) {
                focused = false;
                return
            }

            const ctx = driver.canvas_ctx;

            ctx.beginPath()
            if (this.animationIndex < 10) {
                ctx.moveTo(this.x, this.y)
                ctx.lineTo(this.x + (this.width / 10) * this.animationIndex, this.y)

                ctx.moveTo(this.x + this.width, this.y + this.height)
                ctx.lineTo(this.x - (this.width / 10) * this.animationIndex + this.width, this.y + this.height)

                // y
                ctx.moveTo(this.x + this.width, this.y + (this.height / 10) * (this.animationIndex))
                ctx.lineTo(this.x + this.width, this.y + this.height)

                ctx.moveTo(this.x, this.y + this.height - (this.width / 10) * (this.animationIndex))
                ctx.lineTo(this.x, this.y)
            } else {
                ctx.moveTo(this.x + (this.width / 10) * (this.animationIndex - 10), this.y)
                ctx.lineTo(this.x + this.width, this.y)

                ctx.moveTo(this.x + this.width - (this.width / 10) * (this.animationIndex - 10), this.y + this.height)
                ctx.lineTo(this.x, this.y + this.height)

                // y
                ctx.moveTo(this.x + this.width, this.y)
                ctx.lineTo(this.x + this.width, this.y + (this.height / 10) * (this.animationIndex - 10))

                ctx.moveTo(this.x, this.y + this.height)
                ctx.lineTo(this.x, this.y + this.height - (this.height / 10) * (this.animationIndex - 10))
            }

            disableUpgrades()

            ctx.lineWidth = 2;
            switch (actionState) {
                case ACTION_STATES.MV:
                    ctx.strokeStyle = c_moveLine
                    break;
                case ACTION_STATES.ATK:
                    if (attackGui.selectedTarget && attackGui.hoverOnSelectedTarget) {
                        ctx.strokeStyle = c_atkMarkedTarget
                    } else {
                        ctx.strokeStyle = c_atkTarget
                    }
                    break;
                case ACTION_STATES.GV:
                    ctx.strokeStyle = c_giveLine
                    break;
                default:
                    ctx.strokeStyle = 'white'
                    if (selectedTank === userTank) enableUpgrades()
            }

            ctx.stroke()
        }
    })

    backgroundDriver.run(10);
    objectDriver.run(16);
    guiDriver.run(16)

    updateStats()

    function updateStats() {
        // Info panel
        const player = selectedTank.player;
        const isUser = userTank === selectedTank

        document.querySelector('#name').innerHTML = player.name
        document.querySelector('#id').innerHTML = ` &lt${ getChar(player.position.x) }${ player.position.y + 1 }&gt ${ player._id }`
        document.querySelector('#actions').innerHTML = "Energy: " + player.actions + (isUser && actions !== player.actions ? ` → ${ actions }` : '')
        document.querySelector('#health').innerHTML = "Health: " + player.health
        document.querySelector('#range').innerHTML = "Range: " + player.range
    }

    function updateHint(title, text, color = 'white') {
        if (!title) {
            document.querySelector('#hintPanel').style.display = 'none';
        }

        document.querySelector('#hintPanel').style.display = 'block';
        document.querySelector('#hintPanel h3').innerHTML = title;
        document.querySelector('#hintPanel p').innerHTML = text;

        document.querySelector('#hintPanel h3').style.color = color;
    }

    let actionsToAdd = {}


    function disableUpgrades() {
        upgradeButtons.forEach(a => a.classList.add('disabled'))
    }

    function enableUpgrades() {
        upgradeButtons.forEach(a => a.classList.remove('disabled'))
    }

    document.querySelectorAll("#infoPanel .upgrade").forEach(node => {
        const upgradeName = node.dataset.upgrade;
        const actionCost = parseInt(node.dataset.cost);

        upgradeButtons.push(node.querySelector("a.plus"))
        upgradeButtons.push(node.querySelector("a.minus"))
        upgradeButtons.push(document.querySelector("a.cancel"))
        upgradeButtons.push(document.querySelector("a.confirm"))

        node.querySelector("a.plus").onclick = () => {
            if (node.querySelector("a.plus").classList.contains("disabled")) return;

            if (actions - actionCost < 0) return;

            if (actionsToAdd[upgradeName]) {
                actionsToAdd[upgradeName] += 1;
                actions -= actionCost
            } else {
                actionsToAdd[upgradeName] = 1;
                actions -= actionCost
            }

            node.querySelector(".actionsToAdd").innerHTML = actionsToAdd[upgradeName] > 0 ? `+${ actionsToAdd[upgradeName] }` : ''
            updateStats()
        }

        node.querySelector("a.minus").onclick = () => {
            if (node.querySelector("a.minus").classList.contains("disabled")) return;

            if (actionsToAdd[upgradeName] !== undefined) {
                if (actionsToAdd[upgradeName] > 0) {
                    actionsToAdd[upgradeName] -= 1;
                    actions += actionCost
                }
            } else {
                actionsToAdd[upgradeName] = 0;
            }

            node.querySelector(".actionsToAdd").innerHTML = actionsToAdd[upgradeName] > 0 ? `+${ actionsToAdd[upgradeName] }` : ''
            updateStats()
        }
    })

    document.querySelector("#infoPanel .cancel").onclick = () => {
        if (document.querySelector("a.cancel").classList.contains("disabled")) return;
        Object.keys(actionsToAdd).forEach(k => {
            actions += actionsToAdd[k]
            actionsToAdd[k] = 0
        })

        document.querySelectorAll('.actionsToAdd').forEach(n => n.innerHTML = '')
        updateStats()
    }

    document.querySelector("#infoPanel .confirm").onclick = () => {
        if (document.querySelector("a.cancel").classList.contains("disabled")) return;

        disableUpgrades()

        const fetchPromises = Object.keys(actionsToAdd).map(k =>
            fetch(`/action/${ game._id }/upgrade/${ k }/count/${ actionsToAdd[k] }`, { method: 'POST' })
        )

        Promise.all(fetchPromises).then(() => {
            updateStats()
            enableUpgrades()
            refetch()
        })

        document.querySelectorAll('.actionsToAdd').forEach(n => n.innerHTML = '')
        updateStats()
    }
</script>

<%- include('../../partials/footer.html') %>
</body>

<style>
    html, body {
        background-color: black;
        max-height: fit-content;
        padding-bottom: 40px;
    }

    .panel {
        padding: 15px;
        margin: 15px 30px 15px 15px;

        border: rgba(158, 202, 237, 0.69) solid 1px;
        box-shadow: 0 0 10px rgba(158, 202, 237, 0.45);
    }

    #infoPanel {
        position: fixed;
        right: 0;
    }

    #infoPanel h3 {
        margin-bottom: 0;
    }

    #infoPanel #id {
        margin-top: 5px;
        font-size: 10px;
        color: #fffc4d;
    }

    #infoPanel p {
        color: #b6dad7;
    }

    #hintPanel {
        position: fixed;
        right: 0;
        bottom: 0;
        display: none;

        z-index: 300;
    }

    #hintPanel h3 {
        margin-bottom: 0;
    }

    #hintPanel p {
        margin-top: 5px;
    }

    #winScreen {
        display: none;
        position: fixed;
        left: 50%;
        bottom: 50%;
        transform: translateX(-50%);
        background-color: black
    }

    #infoPanel a {
        font-size: 16px;
        display: inline-block;
        -webkit-user-select: none; /* Safari */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* IE10+/Edge */
        user-select: none; /* Standard */
    }

    #infoPanel a.disabled {
        color: gray;
        cursor: default;
    }

    .upgrade {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .confirm {
        display: flex;
        justify-content: flex-end;
    }
</style>